# DcrnAPI Usage
This guide provides example code for interacting with the JSON-RPC API in go languages.

**Noted**:The port in the example is the testnet, if you want to connect to the mainnet, please change the port to 9109.You can find the default port configuration [here](../../../../Configuration/Conf.md#Port).


## getblockcount
Using getblockcount to Retrieve the Current Block Height.
The following is an example Go application which uses the rpcclient package to connect with a dcrnd instance via Websockets, issues getblockcount to retrieve the current block height, and displays it.
```Go
package main

import (
	"context"
	"io/ioutil"
	"log"
	"path/filepath"

	"github.com/decred/dcrd/dcrutil/v4"
	"github.com/decred/dcrd/rpcclient/v7"
)

func main() {
	// Load the certificate for the TLS connection which is automatically
	// generated by dcrnd when it starts the RPC server and doesn't already
	// have one.
	dcrndHomeDir := dcrutil.AppDataDir("dcrd", false)
	certs, err := ioutil.ReadFile(filepath.Join(dcrndHomeDir, "rpc.cert"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &rpcclient.ConnConfig{
		Host:         "localhost:19109",
		Endpoint:     "ws",
		User:         "yourrpcuser",
		Pass:         "yourrpcpass",
		Certificates: certs,
	}
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Shutdown()

	// Query the RPC server for the current block count and display it.
	ctx := context.Background()
	blockCount, err := client.GetBlockCount(ctx)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("Block count: %d", blockCount)
}
```
Which results in:
```
Block count: 970
```

## getblock 
Using getblock to Retrieve the Genesis Block.The following is an example Go application which uses the rpcclient package to connect with a dcrnd instance via Websockets, issues getblock to retrieve information about the Genesis block, and display a few details about it.
```Go
package main

import (
	"context"
	"io/ioutil"
	"log"
	"path/filepath"
	"time"

	"github.com/decred/dcrd/chaincfg/chainhash"
	"github.com/decred/dcrd/dcrutil/v4"
	"github.com/decred/dcrd/rpcclient/v7"
)

func main() {
	// Load the certificate for the TLS connection which is automatically
	// generated by dcrnd when it starts the RPC server and doesn't already
	// have one.
	dcrndHomeDir := dcrutil.AppDataDir("dcrd", false)
	certs, err := ioutil.ReadFile(filepath.Join(dcrndHomeDir, "rpc.cert"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &rpcclient.ConnConfig{
		Host:         "localhost:19109",
		Endpoint:     "ws",
		User:         "yourrpcuser",
		Pass:         "yourrpcpass",
		Certificates: certs,
	}
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Shutdown()

	// Query the RPC server for the genesis block using the "getblock"
	// command with the verbose flag set to true and the verboseTx flag
	// set to false.
	ctx := context.Background()
	genesisHashStr := "000000cd3a2a818bc752f3502934eb15bb57bf4f2243be1ded8e76f63f1a3962"
	blockHash, err := chainhash.NewHashFromStr(genesisHashStr)
	if err != nil {
		log.Fatal(err)
	}
	block, err := client.GetBlockVerbose(ctx, blockHash, false)
	if err != nil {
		log.Fatal(err)
	}

	// Display some details about the returned block.
	log.Printf("Hash: %v\n", block.Hash)
	log.Printf("Previous Block: %v\n", block.PreviousHash)
	log.Printf("Next Block: %v\n", block.NextHash)
	log.Printf("Merkle root: %v\n", block.MerkleRoot)
	log.Printf("Timestamp: %v\n", time.Unix(block.Time, 0).UTC())
	log.Printf("Confirmations: %v\n", block.Confirmations)
	log.Printf("Difficulty: %f\n", block.Difficulty)
	log.Printf("Size (in bytes): %v\n", block.Size)
	log.Printf("Num transactions: %v\n", len(block.Tx))
}
```
Which results in:
```
Hash: 000000cd3a2a818bc752f3502934eb15bb57bf4f2243be1ded8e76f63f1a3962
Previous Block: 00000066f1bc32f0af6b1e1c6df99ed6e5960558c432cfd752f0111ad65b911e
Merkle root: 68211b7f5739b9dfbaa6cb646bc69acc3d6a68bbab5d2a53c6145bc8995bac11
Timestamp: 2022-05-25 04:58:46 +0000 UTC
Confirmations: 919
Difficulty: 1.000000
Size (in bytes): 4788
Num transactions: 1
```

## notifyblocks
Using notifyblocks to Receive blockconnected and blockdisconnected Notifications (Websocket-specific).The following is an example Go application which uses the rpcclient package to connect with a dcrnd instance via Websockets and registers for blockconnected and blockdisconnected notifications with notifyblocks. It also sets up handlers for the notifications.
```Go
package main

import (
	"context"
	"io/ioutil"
	"log"
	"path/filepath"
	"time"

	"github.com/decred/dcrd/dcrutil/v4"
	"github.com/decred/dcrd/rpcclient/v7"
)

func main() {
	// Setup handlers for blockconnected and blockdisconnected
	// notifications.
	ntfnHandlers := rpcclient.NotificationHandlers{
		OnBlockConnected: func(blockHeader []byte, transactions [][]byte) {
			log.Printf("Block connected: %x (%d txs)", blockHeader, len(transactions))

		},
		OnBlockDisconnected: func(blockHeader []byte) {
			log.Printf("Block disconnected: %x", blockHeader)
		},
	}

	// Load the certificate for the TLS connection which is automatically
	// generated by dcrnd when it starts the RPC server and doesn't already
	// have one.
	dcrndHomeDir := dcrutil.AppDataDir("dcrd", false)
	certs, err := ioutil.ReadFile(filepath.Join(dcrdHomeDir, "rpc.cert"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.
	connCfg := &rpcclient.ConnConfig{
		Host:         "localhost:19109",
		Endpoint:     "ws",
		User:         "yourrpcuser",
		Pass:         "yourrpcpass",
		Certificates: certs,
	}
	client, err := rpcclient.New(connCfg, &ntfnHandlers)
	if err != nil {
		log.Fatal(err)
	}

	// Register for blockconnected and blockdisconneted notifications.
	ctx := context.Background()
	if err := client.NotifyBlocks(ctx); err != nil {
		client.Shutdown()
		log.Fatal(err)
	}

	// For this example, gracefully shutdown the client after 10 seconds.
	// Ordinarily when to shutdown the client is highly application
	// specific.
	log.Println("Client shutdown in 10 seconds...")
	time.AfterFunc(time.Second*10, func() {
		log.Println("Client shutting down...")
		client.Shutdown()
		log.Println("Client shutdown complete.")
	})

	// Wait until the client either shuts down gracefully (or the user
	// terminates the process with Ctrl+C).
	client.WaitForShutdown()
}
```
Which results in:
```
Client shutdown in 10 seconds...
Client shutting down...
```
